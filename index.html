<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Descubro ‚Äî Artist Network</title>

  <!-- Afacad font -->
  <link href="https://fonts.googleapis.com/css2?family=Afacad:wght@400;600&display=swap" rel="stylesheet">

  <!-- D3.js -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #121212;
      color: #fff;
      font-family: 'Afacad', 'Poppins', sans-serif;
    }

    text {
      font-size: 12px;
      fill: #ddd;
      pointer-events: none;
    }

    circle {
      stroke: #121212;
      stroke-width: 1px;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    circle:hover {
      transform: scale(1.25);
    }

    line {
      stroke-opacity: 0.5;
    }

    #loader {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #ff7a00;
      text-align: center;
    }

    #loader::after {
      content: "";
      display: block;
      width: 40px;
      height: 40px;
      margin: 12px auto;
      border-radius: 50%;
      border: 5px solid #ff7a00;
      border-color: #ff7a00 transparent #ff7a00 transparent;
      animation: spin 1.2s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .tooltip {
      position: absolute;
      background: #1f1f1f;
      padding: 6px 8px;
      border: 1px solid #333;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      font-size: 12px;
      color: #fff;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      transition: opacity 0.3s ease;
    }

    .legend text {
      fill: #ccc;
      font-size: 13px;
    }
  </style>
</head>

<body>
  <div id="loader">Loading artist network...</div>

  <script>
    console.log("‚úÖ Script loaded ‚Äî starting Descubro visualization...");

    const width = window.innerWidth;
    const height = window.innerHeight;
    const svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

    const artistAPI = "https://alexjmiller95.bubbleapps.io/version-test/api/1.1/obj/Artist";
    const connectionAPI = "https://alexjmiller95.bubbleapps.io/version-test/api/1.1/obj/ArtistConnection?limit=500";

    Promise.all([
      fetch(artistAPI).then(res => res.json()),
      fetch(connectionAPI).then(res => res.json())
    ])
    .then(([artistData, connectionData]) => {
      document.getElementById("loader").style.display = "none";

      const artistsRaw = artistData?.response?.results || [];
      const connectionsRaw = connectionData?.response?.results || [];

      console.log("üéß Artists fetched:", artistsRaw.length);
      console.log("üéµ Connections fetched:", connectionsRaw.length);

      const clean = str => str ? str.trim().toLowerCase() : "";

      // --- Normalize artist genres ---
      const artistMap = new Map();
      artistsRaw.forEach(a => {
        const name = clean(a.name_text);
        if (!name) return;

        let genres = [];
        if (Array.isArray(a.genre)) {
          genres = a.genre.map(g => g.toLowerCase().trim());
        } else if (typeof a.genre === "string") {
          genres = a.genre.split(/[,/]/).map(g => g.trim().toLowerCase()).filter(g => g);
        } else if (a.genre_text) {
          genres = a.genre_text.split(/[,/]/).map(g => g.trim().toLowerCase()).filter(g => g);
        }

        if (genres.length === 0) genres = ["other"];

        artistMap.set(name, {
          id: name,
          name: a.name_text.trim(),
          genres: genres
        });
      });

      // --- Add any missing artists from connections ---
      connectionsRaw.forEach(c => {
        const a1 = clean(c.artist_1);
        const a2 = clean(c.artist_2);
        if (a1 && !artistMap.has(a1))
          artistMap.set(a1, { id: a1, name: c.artist_1.trim(), genres: [c.genre?.toLowerCase() || "other"] });
        if (a2 && !artistMap.has(a2))
          artistMap.set(a2, { id: a2, name: c.artist_2.trim(), genres: [c.genre?.toLowerCase() || "other"] });
      });

      // --- Build links ---
      const links = connectionsRaw
        .map(c => ({
          source: clean(c.artist_1),
          target: clean(c.artist_2),
          genre: c.genre ? c.genre.toLowerCase() : "other",
          strength: c.connection_strength || 1
        }))
        .filter(l => l.source && l.target && artistMap.has(l.source) && artistMap.has(l.target));

      const nodes = Array.from(artistMap.values());
      console.log("üß© Final nodes:", nodes.length, "Links:", links.length);

      // --- Genre clustering setup ---
      const allGenres = Array.from(new Set(nodes.flatMap(n => n.genres).concat(links.map(l => l.genre))));
      const color = d3.scaleOrdinal(d3.schemeTableau10).domain(allGenres);

      const genreCenters = {};
      const clusterRadius = 300;
      const angleStep = (2 * Math.PI) / allGenres.length;
      allGenres.forEach((g, i) => {
        genreCenters[g] = {
          x: width / 2 + clusterRadius * Math.cos(i * angleStep),
          y: height / 2 + clusterRadius * Math.sin(i * angleStep)
        };
      });

      // --- D3 simulation ---
      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(100))
        .force("charge", d3.forceManyBody().strength(-200))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide(18))
        .force("genreClusterX", d3.forceX(d => {
          const avgX = d.genres.map(g => genreCenters[g]?.x || width / 2)
            .reduce((a, b) => a + b, 0) / d.genres.length;
          return avgX;
        }).strength(0.05))
        .force("genreClusterY", d3.forceY(d => {
          const avgY = d.genres.map(g => genreCenters[g]?.y || height / 2)
            .reduce((a, b) => a + b, 0) / d.genres.length;
          return avgY;
        }).strength(0.05));

      // --- Draw links ---
      const link = svg.append("g")
        .attr("stroke-opacity", 0.6)
        .selectAll("line")
        .data(links)
        .join("line")
        .attr("stroke-width", d => Math.max(1, d.strength))
        .attr("stroke", d => color(d.genre));

      // --- Draw nodes ---
      const node = svg.append("g")
        .selectAll("circle")
        .data(nodes)
        .join("circle")
        .attr("r", 8)
        .attr("fill", d => color(d.genres[0] || "other"))
        .call(drag(simulation))
        .on("mouseover", (event, d) => showTooltip(event, d))
        .on("mouseout", hideTooltip);

      // --- Labels ---
      const label = svg.append("g")
        .selectAll("text")
        .data(nodes)
        .join("text")
        .text(d => d.name)
        .attr("font-size", 11)
        .attr("x", 10)
        .attr("y", 3);

      // --- Tooltip ---
      const tooltip = d3.select("body").append("div").attr("class", "tooltip");
      function showTooltip(event, d) {
        tooltip.transition().duration(200).style("opacity", 1);
        tooltip.html(`<strong>${d.name}</strong><br>Genres: ${d.genres.join(", ")}`)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 20) + "px");
      }
      function hideTooltip() {
        tooltip.transition().duration(200).style("opacity", 0);
      }

      // --- Update positions ---
      simulation.on("tick", () => {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);

        label
          .attr("x", d => d.x + 10)
          .attr("y", d => d.y + 3);
      });

      // --- Dragging behavior ---
      function drag(simulation) {
        function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }
        function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }
        function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        }
        return d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended);
      }

      // --- Legend ---
      const legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", "translate(20, 20)");

      allGenres.forEach((g, i) => {
        const y = i * 22;
        legend.append("circle")
          .attr("cx", 0)
          .attr("cy", y)
          .attr("r", 6)
          .attr("fill", color(g));
        legend.append("text")
          .attr("x", 12)
          .attr("y", y + 4)
          .text(g);
      });
    })
    .catch(err => {
      document.getElementById("loader").textContent = "‚ö†Ô∏è Failed to load data.";
      console.error("üö® Fetch or visualization error:", err);
    });
  </script>
</body>
</html>
